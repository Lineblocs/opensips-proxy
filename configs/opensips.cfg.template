#
# Lineblocs routing scripts
#  
# designed for OpenSIPS Solutions
#


####### Global Parameters #########

/* uncomment the following lines to enable debugging */
debug_mode=no

log_level=3
xlog_level=4
stderror_enabled=yes
syslog_facility=LOG_LOCAL0

auto_scaling_cycle=3  # do auto-scaling checks once every 3 seconds
{{{udp_support}}}
{{{tcp_support}}}
#auto_scaling_profile = PROFILE_UDP
#     scale up to 6 on 70% for 4 cycles within 5   
#     scale down to 2 on 18% for 10 cycles
#auto_scaling_profile = PROFILE_TCP
#     scale up to 6 on 70% for 4 cycles within 5   
#     scale down to 2 on 18% for 10 cycles
auto_scaling_profile = PROFILE_TIMER
     scale up to 6 on 70% for 4 cycles within 5   
     scale down to 2 on 18% for 10 cycles

/* uncomment the next line to enable the auto temporary blacklisting of
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns
   lookup failures (default disabled) */
#dns_try_ipv6=yes


auto_aliases=no
tcp_accept_aliases=1

timer_workers = 2 use_auto_scaling_profile PROFILE_TIMER

# UDP support
socket=udp:0.0.0.0:5060
socket=wss:0.0.0.0:7443
#listen=udp:0.0.0.0:5060

# TCP support
#listen=tcp:127.0.0.1:5080


# TLS support
#listen=tcp:127.0.0.1:5080


socket=hep_udp:127.0.0.1:9060

#socket=udp:{{{public_ipv4}}}:5060   # CUSTOMIZE ME
alias=udp:{{{public_ipv4}}}:5060
advertised_address="{{{public_ipv4}}}"



####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

loadmodule "proto_wss.so"
modparam("proto_wss", "wss_port", 7443)

loadmodule "tls_openssl.so"
loadmodule "tls_mgm.so"
modparam("tls_mgm", "client_domain", "{{{deployment_domain}}}")
modparam("tls_mgm", "verify_cert", "[{{{deployment_domain}}}]0")
modparam("tls_mgm", "require_cert", "[{{{deployment_domain}}}]0")
modparam("tls_mgm", "tls_method", "[{{{deployment_domain}}}]TLSv1_2")
modparam("tls_mgm", "certificate", "[{{{deployment_domain}}}]/etc/opensips/tls/fullchain1.pem")
modparam("tls_mgm", "private_key", "[{{{deployment_domain}}}]/etc/opensips/tls/privkey1.pem")
modparam("tls_mgm", "ca_list", "[{{{deployment_domain}}}]/etc/ssl/certs/ca-certificates.crt")

modparam("tls_mgm", "server_domain", "{{{deployment_domain}}}")
modparam("tls_mgm", "verify_cert", "[{{{deployment_domain}}}]0")
modparam("tls_mgm", "require_cert", "[{{{deployment_domain}}}]0")
modparam("tls_mgm", "tls_method", "[{{{deployment_domain}}}]TLSv1_2")
modparam("tls_mgm", "certificate", "[{{{deployment_domain}}}]/etc/opensips/tls/fullchain1.pem")
modparam("tls_mgm", "private_key", "[{{{deployment_domain}}}]/etc/opensips/tls/privkey1.pem")
modparam("tls_mgm", "ca_list", "[{{{deployment_domain}}}]/etc/ssl/certs/ca-certificates.crt")



#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)


loadmodule "db_mysql.so"

loadmodule "auth.so"
loadmodule "auth_db.so"
# ----- auth_db params -----
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
#modparam("auth_db", "db_url","mysql://lineblocs:E0N798KU5TEh@172.31.15.129/opensips")
modparam("auth_db", "db_url","mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 1)


loadmodule "domain.so"
# ----- domain params -----
#modparam("domain", "db_url", "mysql://lineblocs:E0N798KU5TEh@172.31.15.129/opensips")
modparam("domain", "db_url", "mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")
modparam("domain", "db_mode", 0)   # Use caching


#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 1)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"


loadmodule "sqlops.so"
# default URL
modparam("sqlops","db_url","mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")


#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)


#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "db_mode",   0)
modparam("usrloc", "db_url", "mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "received_avp", "$avp(received)")

/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)


loadmodule "nathelper.so"
modparam("nathelper", "ping_nated_only", 1) # Ping only clients behind NAT
modparam("nathelper", "sipping_bflag", "8")
modparam("nathelper", "received_avp", "$avp(received)")
modparam("nathelper", "force_socket", "udp:{{{public_ipv4}}}:7722")

#loadmodule "rtpproxy.so"
# RTPProxy setup
#modparam("rtpproxy", "rtpproxy_sock", "udp:{{{public_ipv4}}}:7722")
#modparam("rtpproxy", "db_url", "mysql://lineblocs:E0N798KU5TEh@172.31.15.129/opensips")
#modparam("rtpproxy", "db_table", "rtpproxy_sockets")
#modparam("rtpproxy", "rtpp_socket_col", "rtpproxy_sock")
#modparam("rtpproxy", "rtpproxy_disable_tout", 20)
#modparam("rtpproxy", "rtpproxy_autobridge", 1)
#modparam("rtpproxy", "rtpproxy_retr", 2)
#modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

loadmodule "dialog.so"
#modparam("dialog", "db_url", "mysql://lineblocs:E0N798KU5TEh@172.31.15.129/opensips")
modparam("dialog", "db_mode", 0)

### RTPengine protocol
loadmodule "rtpengine.so"
modparam("rtpengine", "db_url", "mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")
#modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

loadmodule "uac.so"

#### ACCounting module
loadmodule "acc.so"
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)


#### UDP protocol
#loadmodule "proto_udp.so"
loadmodule "proto_udp.so"
modparam("proto_udp", "udp_port", 5060)

## TCP protocol
#loadmodule "proto_tcp.so"
#modparam("proto_tcp", "tcp_port", 5065)


## TCP protocol
#loadmodule "proto_tcp.so"
#modparam("proto_tcp", "tcp_port", 5065)





# ----- multi-module params -----
modparam("alias_db|auth_db|usrloc", "use_domain", 1)

loadmodule "rest_client.so"
modparam("rest_client", "connection_timeout", 300)
modparam("rest_client", "connect_poll_interval", 2)
loadmodule "json.so"

loadmodule "options.so"

### CHANGEME mysql uri here if you do sip_capture()
loadmodule "sipcapture.so"
modparam("sipcapture", "db_url", "mysql://{{{db_user}}}:{{{db_pass}}}@{{{db_host}}}/{{{db_opensips}}}")
modparam("sipcapture", "capture_on", 0)
modparam("sipcapture", "hep_capture_on", 0)
modparam("sipcapture", "hep_route", "CAPTURE_HEP_ROUTE")

loadmodule "proto_hep.so"
# use Homer5 formats
modparam("proto_hep", "homer5_on", 1)
user_agent_header="User-Agent: Lineblocs SIP router (powered by OpenSIPs)"

loadmodule "regex.so"

####### Routing Logic ########

# main request routing logic
route{
	$avp(G_PUBLIC_IP) = "{{{public_ipv4}}}";
	$avp(API_URL) = "{{{api_url}}}";
	$var(WPC) = $(hdr(Via)[0]{via.transport}{s.tolower});

    if ($var(WPC) == "ws" || $var(WPC) == "wss"){
        setflag("SRC_WS");
		setbflag("SRC_WS");
		force_tcp_alias();
	} # Method 2: Check the User-Agent string (Backup for JsSIP)
	else if ($ua =~ "JsSIP" || $ua =~ "sip.js") {
	    setflag("SRC_WS");
	    setbflag("SRC_WS");
		force_tcp_alias();
	    xlog("L_INFO", "MATCH: WebRTC detected via User-Agent ($ua)\n");
	}		

	# replace user agent with the branded one configured in database
	if(remove_hf("User-Agent"))
	{
		# User Agent header was removed
		append_hf("User-Agent: Lineblocs SIP router (powered by OpenSIPs)\r\n"); 
	}

	if ($ua=~"friendly-scanner") 
	{
		 xlog("L_ERROR", "Auth error for $fU@$fd from $si method $rm user-agent (friendly-scanner)\n");
		 drop();
		 exit;
    }

	# start capturing sip packets
	sip_capture();

	if (is_method("OPTIONS")) 
	{
		xlog("got options request..");
		if (is_myself("$rd")) {
			xlog("validated options req. sending response.");
			seturi("sip:$rd");
			options_reply();
		}
		exit;
	}


	if (!mf_process_maxfwd_header(10)) 
	{
		sl_send_reply(483,"Too Many Hops");
		exit;
	}

	if (has_totag()) 
	{
		route(WITHINDLG);
    		exit;
	}	

	# Cancel processing
	if (is_method("CANCEL"))
	{
		if (t_check_trans())
		{
			t_relay();
		}
		exit;
	}

	# If R-URI contains alias (added via NAT contact fixing), restore the real destination
	t_check_trans();

	if ( !(is_method("REGISTER")  ) ) 
	{
		if (is_myself("$fu")) 
		{
				xlog("REG TRY register..");
		} else {
			# if caller is not local, then called number must be local
			if (!is_myself("$rd")) 
			{
				xlog("REG sending back 403. we don't know this domain..");
				send_reply(403,"Relay forbidden");
				exit;
			}
		}
	}

	# preloaded route checking
	if (loose_route()) 
	{
		#xlog("L_ERR", "Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
		if (!is_method("ACK")) 
		{
			sl_send_reply(403,"Preload Route denied");
		}

		exit;
	}

	# record routing
	if (!is_method("REGISTER|MESSAGE")) 
	{
		record_route();
	}

	# If we are not the final destination the call is
	# to a external destination
	if (!is_myself("$rd")) 
	{
		#xlog("is_myself failed routing to relay..");
		append_hf("P-hint: outbound\r\n"); 
		route(RELAY);
	}

	# We dont accept publish or subscribe here
	if (is_method("PUBLISH|SUBSCRIBE"))
	{
		sl_send_reply(503, "Service Unavailable");
		exit;
	}

	if (is_method("REGISTER"))
	{

		xlog("received REGISTER from SIP device\r\n");
		force_rport();
		fix_nated_register();
		route(SIP_DEVICE_REGISTRATION);
		exit;
	}

	if ($rU==NULL) 
	{
		# user needs to set correct addresses to call
		sl_send_reply(484,"Address Incomplete");
		exit;
	}

	xlog("RECEIVED KEY: $hdr(X-LineBlocs-Key)\r\n");
	xlog("RECEIVED AGENT: $hdr(User-Agent)\r\n");
	if ($hdr(X-LineBlocs-Key) != NULL) { #internal asterisk
		xlog("RECEIVED CALL FROM MEDIA SERVER\r\n");
		route(INTERNAL_MS_ROUTING);
		exit;
	}

	xlog("User agent is: $hdr(User-Agent)\r\n");
	# scenario to handle calls from either subscribers or from SIPml5 agents
	if (is_registered("location","$fu"))
	{
		xlog("RECEIVED CALL FROM EXTENSION\r\n");
		route(INTERNAL_EXTENSION_ROUTING);
		exit;
	}

	# handle internal subscriber workflow or calls received from DID numbers
	if (is_method("INVITE")) 
	{
		xlog("RECEIVED CALL FROM PSTN\r\n");
		route(PSTN_ROUTING);
		exit;
	}

	route(RELAY);
}

route[WITHINDLG] {
    # Handle in-dialog requests (ACK/BYE/reINVITE/UPDATE/INFO/OPTIONS/etc.)
    # Must be called only when has_totag() is true.

    # ACK is special: it may be hop-by-hop and is not always a transaction in the same way.
	# 1) Follow the Route set (Record-Route path)
    if (!loose_route()) {
        if (is_method("ACK")) {
            # ACK for a local negative reply (no Route set / no dialog path)
            exit;
        }
        sl_send_reply(404, "Not here");
        exit;
    }
    
	# Optional: if WS/WSS side is involved, reinforce connection aliasing
	# Optional: reinforce aliasing only for WS/WSS traffic

    # (Do NOT run for BYE or INFO without SDP)
    if ((is_method("INVITE") || is_method("UPDATE")) && has_body("application/sdp")) {
    	# Use offer here because it is a new SDP offer inside the dialog
		# route(RTPENGINE_OFFER);i
		rtpengine_use_set(1);	
		rtpengine_manage();
    }

    # BYE: relay it, then clean RTPengine.
    # Deleting before relay can work, but deleting after relay is safer operationally.
    if (is_method("BYE")) {
        if (!t_relay()) {
            sl_reply_error();
            exit;
        }

        rtpengine_use_set(1);
        rtpengine_delete();

        exit;
    }

	$var(WPC) = $(hdr(Via)[0]{via.transport}{s.tolower});
	$var(WPD) = $(ru{uri.param,transport});
    if ($var(WPD) == "ws" || $var(WPD) == "wss") {
        xlog("L_INFO", "Client is WebSocket - Fixing Contact\n");
        force_tcp_alias();
    }

    # Default: relay all other in-dialog requests
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

route[RELAY] {

    if (is_method("INVITE")) {
		t_on_branch("PER_BRANCH_OPS");
        t_on_reply("HANDLE_NAT");
        t_on_failure("MISSED_CALL");

		# record_route();

        # --- Source transport detection ---
        # Prefer $proto over Via parsing
		$var(WPD) = $(ru{uri.param,transport});
		$var(WPC) = $(hdr(Via)[0]{via.transport}{s.tolower});

		#	if ($socket_in(port) == 7443){
 		#        $var(WPC) = "wss";
		#	}

        if ($var(WPC) == "ws" || $var(WPC) == "wss") {
			xlog("L_INFO", "Client is WebSocket - Fixing Contact\n");
            setflag("SRC_WS");
    		setbflag("SRC_WS"); 
			force_tcp_alias();
	    	fix_nated_contact();
        }
		if ($var(WPD) == "ws" || $var(WPD) == "wss") {
        	xlog("L_INFO", "Client is WebSocket - Fixing Contact\n");
            setflag("DST_WS");
            setbflag("DST_WS");
        	#        force_tcp_alias();
            fix_nated_contact();
        } else if (nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact")) {
            fix_nated_contact();
        }

		$var(callee_proto) = "";

        # --- Destination transport detection ---
        # After lookup(), $ru points to the selected contact.
        if (lookup("location")) {
            $var(callee_proto) = $(ru{uri.param,transport});
        } else {
            if ($du) {
                $var(callee_proto) = $(du{uri.param,transport});
                xlog("L_INFO", "Routing to Gateway/Outbound: $du\n");
            } 
	  #   else {
           #     send_reply(404, "User Not Found");
           #     exit;
           # }
        }

		if ($var(callee_proto) == "") {
             if ($ru =~ "transport=ws" || $ru =~ "transport=wss") {
                 $var(callee_proto) = "ws";
             }
        }

        if ($var(callee_proto) == "ws" || $var(callee_proto) == "wss") {
            setflag("DST_WS");
			setbflag("DST_WS");
            xlog("L_INFO", "Destination identified as WebSocket\n");
        } else {
        	#    resetflag("DST_WS");
			#    resetbflag("DST_WS");
            xlog("L_INFO", "Destination identified as Standard SIP\n");
        }

        # --- RTPengine offer on initial INVITE ---
        if (has_body("application/sdp")) {
            route(RTPENGINE_OFFER);
        }
    }

    # Relay ALL methods (INVITE, BYE, ACK, UPDATE, INFO, etc.)
    if (!t_relay()) {
        sl_reply_error();
    }

    exit;
}


route[INTERNAL_MS_ROUTING] {
	if ($hdr(X-LineBlocs-Key) != "{{{lineblocs_key}}}") { #internal asterisk
		xlog("invalid routing key received.\r\n");
		remove_hf("X-LineBlocs-Key");
		exit;
	}

	remove_hf("X-LineBlocs-Key");
	xlog("received media server request from $si\r\n");
	if (is_method("INVITE")) 
	{
		xlog("routing call invite.\r\n");
		# set the SIP call ID
		$var(body) = "callid=" + $hdr(Call-ID) + "&apiid=" + $hdr(X-LineBlocs-API-CallId) + "&source=" + $si;
		$var(reg) = "/\+/%2B/g";
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_post("{{{api_url}}}/call/setSIPCallID", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), MS_UPDATED_CALL_ID);
		exit;
	}

	exit;
}


route[MS_UPDATED_CALL_ID] {
	if ($var(rcode) != 200) 
	{
		send_reply(500, "Media server Routing Failed (scenario 4)");
		exit;
	}

	xlog("set SIP call ID successfully. routing call now...\r\n");
	if ($hdr(X-Lineblocs-User-SIP-Trunk) == "true") 
	{
		route(RELAY_TO_USER_TRUNK);
		exit;
	} else {
		if ($hdr(X-LineBlocs-Route-Type) == "extension")
		{
			xlog("routing to extension...\r\n");

			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			async(rest_get("{{{api_url}}}/user/incomingMediaServerValidation?source=$si&addr=$si", $var(body), $var(ct), $var(rcode)), INCOMING_MS_VALIDATE_1_ROUTE);
			#route(RELAY);
			exit;
		}

		if ($hdr(X-LineBlocs-Route-Type) == "pstn")
		{
			#xlog("L_NOTICE", "calling URL: {{{api_url}}}/user/getPSTNProviderIP?from=$fU&to=$tU&domain=$hdr(X-LineBlocs-Domain)");

			xlog("routing to pstn...\r\n");

			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			async(rest_get("{{{api_url}}}/user/incomingMediaServerValidation?source=$si&addr=$si", $var(body), $var(ct), $var(rcode)), INCOMING_MS_VALIDATE_2_ROUTE);
			exit;
		}
	}
}

route[INTERNAL_EXTENSION_ROUTING] {
	xlog("Using registered routing..\r\n");
	if (is_method("INVITE")) 
	{
		xlog("Processing INVITE request..\r\n");
		xlog("request number before URL decode: $rU\r\n");
		xlog("to number before URL decode: $tU\r\n");
		$var(reg) = "/%2B|%E2|%80|%AC|%91//g";
		$var(reqnum) = $(rU{re.subst,$var(reg)});
		$var(tonum) = $(tU{re.subst,$var(reg)});

		xlog("request number after URL decode: $(var(reqnum))\r\n");
		xlog("to number after URL decode: $(var(tonum))\r\n");

		if($var(reqnum) =~ "[0-9]{1,}") 
		{
			## call to PSTN
			if ($var(reqnum)=~"^[0-9]{9,}") 
			{
					$var(query) = "number=" + $var(tonum) + "&domain=" + $fd + "&addr=" + $si;
					$var(reg) = "/\+/%2B/g";

					rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
					async(rest_get("{{{api_url}}}/user/verifyCallerByDomain?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), VERIFY_CALLER_ROUTE);
					exit;
			} else if ($var(reqnum)=~"^[0-9]{1,5}$") { ## call to another end device
				$var(query) = "username=" + $fu + "&domain=" + $fd + "&routerip=" +  $avp(G_PUBLIC_IP) + "&addr=" + $si;
				$var(reg) = "/\+/%2B/g";

				rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
				async(rest_get("{{{api_url}}}/user/getUserAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), ENDPOINT_QUERY_ROUTE);
				exit;	
			} else if ($var(reqnum)=~"^\*[1-9]+") { ## media service call
				$var(query) = "username=" + $fu + "&domain=" + $fd + "&routerip=" +  $avp(G_PUBLIC_IP) + "&addr=" + $si;
				$var(reg) = "/\+/%2B/g";

				rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
				async(rest_get("{{{api_url}}}/user/getUserAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), MEDIASERVICE_QUERY_ROUTE);
				exit;
			} else {
				# dial pattern isnt unsupported
				send_reply(400, "Dial pattern not supported (scenario 1)");
				exit;
			}
		} else {
			# dial pattern isnt unsupported
			send_reply(400, "Dial pattern not supported (scenario 2)");
			exit;
		}
	}
}

route[PSTN_ROUTING] {
	xlog("SOURCE IP IS: $si");
	if ($hdr(X-LineBlocs-RingSubscriber) == "true")
	{
		xlog("sending to extension...\r\n");
		route(RELAY);
		exit;
	} else {
		$var(query) = "did=" + $tU + "&number=" + $fU + "&source=" + $si + "&routerip=" +  $avp(G_PUBLIC_IP) + "&addr=" + $si;
		$var(reg) = "/\+/%2B/g";

		rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_get("{{{api_url}}}/user/incomingDIDValidation?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), INCOMING_VALIDATION);
		exit;
	}
}

route[SIP_DEVICE_REGISTRATION] {
	# check if its a hosted trunk or SIP device
	# we can verify this by checking if the domain ends in pstn.lineblocs.com
	if (pcre_match("$td", "pstn\.lineblocs.com")) {
		xlog("L_INFO", "Hosted trunk was matched\n");
		$var(query) = "domain=" + $fd + "&ip=" + $si + "&addr=" + $si + "&todomain=" + $td + "&fromuser=" + $fU + "&touser=" + $tU;
		$var(reg) = "/\+/%2B/g";
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_get("{{{api_url}}}/user/hostedSIPTrunkLookup?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), HOSTED_TRUNK_REGISTER);
		exit;
	} else {
		$var(query) = "domain=" + $fd + "&ip=" + $si + "&addr=" + $si;
		$var(reg) = "/\+/%2B/g";
		xlog("REG calling API..");
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_get("{{{api_url}}}/user/ipWhitelistLookup?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), REGISTER);
		exit;
	}
}



route[BYE_QUERY_ROUTE] {
    $ru = "sip:" + $rU + "@" + $avp(value);
	# removing the rtpproxy session

	if(is_method("CANCEL|BYE"))
	{
		#rtpproxy_unforce();
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
		send_reply(500,"Internal Error");
	};

	#route(POST_CALL_PROC_ROUTE);
}

route[INCOMING_VALIDATION] {
	if ($var(rcode) != 200) 
	{
		# lookup user SIP trunks next
		xlog("SOURCE IP IS: $si");
		$var(query) = "did=" + $tU + "&number=" + $fU + "&source=" + $si + "&routerip=" +  $avp(G_PUBLIC_IP) + "&addr=" + $si + "&fromdomain=" + $fd;
		$var(reg) = "/\+/%2B/g";

		rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_get("{{{api_url}}}/user/incomingTrunkValidation?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), TRUNK_VALIDATION);
		exit;
	}

	switch($var(body))
	{
        case "user_sip_trunk":
			append_hf("X-LineBlocs-Fulfill-Type: user_sip_trunk\r\n");
			rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
			$var(reg) = "/\+/%2B/g";
			async(rest_get("{{{api_url}}}/user/processSIPTrunkCall?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), USER_SIP_TRUNK);
        break;
        case "network_managed":
			append_hf("X-LineBlocs-Fulfill-Type: network_managed\r\n");
			rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
			$var(reg) = "/\+/%2B/g";
			async(rest_get("{{{api_url}}}/user/getDIDAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), DID_ASSIGNED);
        break;
        case "byo_carrier":
			append_hf("X-LineBlocs-Fulfill-Type: byo_carrier\r\n");
			rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
			$var(reg) = "/\+/%2B/g";
			async(rest_get("{{{api_url}}}/user/getDIDAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), DID_ASSIGNED);
        break;
	}
}

route[TRUNK_VALIDATION] {
	if ($var(rcode) != 200)
	{
		# lookup user SIP trunks next
		send_reply(500, "PSTN Routing Failed #2");
		exit;
	}

	append_hf("X-LineBlocs-Fulfill-Type: user_sip_trunk\r\n");
	rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";
	async(rest_get("{{{api_url}}}/user/getTrunkAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), TRUNK_ASSIGNED);
}


route[USER_SIP_TRUNK] {
	if ($var(rcode) != 200) 
	{
		send_reply(500, "PSTN Routing Failed #3");
		exit;
	}

	rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	append_hf("X-Lineblocs-User-SIP-Trunk-Addr: $var(body)\r\n");
	$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";
	async(rest_get("{{{api_url}}}/user/getDIDAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), DID_ASSIGNED);
}

route[INCOMING_VALIDATION_2] {
	if ($var(rcode) != 204) 
	{
		send_reply(500, "PSTN Routing Failed #4");
		exit;
	}

	rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	$var(query) = "did=" + $tU + "&from=" + $fU + "&source=" + $si + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";
	async(rest_get("{{{api_url}}}/user/getDIDAssignedIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), DID_ASSIGNED);
}

route[DID_ASSIGNED] {
	if ($var(rcode) != 200) 
	{
		send_reply(400, "Bad Request -- DID lookup failed");
		exit;
	}

	$ru = "sip:" + $rU + "@" + $var(body);
	rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	$var(query) = "did=" + $tU + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";
	async(rest_get("{{{api_url}}}/user/getDIDAcceptOption?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), CALL_ACTION);
}

route[TRUNK_ASSIGNED] {
	if ($var(rcode) != 200) 
	{
		send_reply(400, "Bad Request");
		exit;
	}

	$ru = "sip:" + $rU + "@" + $var(body);
	#rest_append_hf("X-Lineblocs-Carrier-Auth: {{{carrier_key}}}");
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	append_hf("X-LineBlocs-Key: {{{lineblocs_key}}}\r\n");
	append_hf("X-LineBlocs-Accept-Call-Type: voice\r\n");
	append_hf("X-LineBlocs-Direction: outgoing-proxy-trunk\r\n");
	append_hf("X-Lineblocs-Trunk-SourceIP: $fd\r\n");
	route(RELAY);
}

route[CALL_ACTION] {
	if ($var(rcode) != 200) 
	{
		send_reply(400, "Bad Request");
		exit;
	}

	append_hf("X-LineBlocs-Key: {{{lineblocs_key}}}\r\n");
	switch($var(body))
	{
		case "accept-call":
			log("accept-call action is set..");
			append_hf("X-LineBlocs-Accept-Call-Type: voice\r\n");
			append_hf("X-LineBlocs-Direction: incoming-proxy\r\n");
			rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
			async(rest_get("{{{api_url}}}/getBestRTPProxy", $var(body), $var(ct), $var(rcode)), RTPPROXY_SELECTION);
			#route(RELAY);
		break;
		case "accept-fax":
			log("accept-fax action is set..");
			append_hf("X-LineBlocs-Accept-Call-Type: fax\r\n");
			append_hf("X-LineBlocs-Direction: incoming-proxy\r\n");
			route(RELAY);
		break;
	}
}

route[RTPPROXY_SELECTION] {
	if ($var(rc) < 0) 
	{
		send_reply(500, "Server Internal Error");
		exit;
	}

	if ($var(rcode) != 200) 
	{
		send_reply(403, "Forbidden (scenario 1)");
		exit;
	}

	xlog("got preferred RTP proxy\r\n");
	xlog("setting SIP header\r\n");
	append_hf("X-LineBlocs-RTPProxy: $var(body)\r\n");
	route(RELAY);
}

route[REGISTER] {
	xlog("REG in register resume.. rc = $rc\r\n");
	$var(rc) = $rc;

	if ($var(rc) < 0) 
	{
		send_reply(500, "Server Internal Error");
		exit;
	}

	if ($var(rcode) != 204) 
	{
		send_reply(403, "Forbidden (scenario 2)");
		exit;
	}

	xlog("REG checking auth rc = $rc\r\n");
	$var(auth_code) = www_authorize("", "subscriber");
	if ($var(auth_code) == -1 || $var(auth_code) == -2) 
	{
			## uncomment to enable fail2ban
			#xlog("L_NOTICE","REG Auth error for $fU@$fd from $si cause $var(auth_code)");
			#exit;
	}

	if ( $var(auth_code) < 0 ) 
	{
			www_challenge("", "auth,auth-int");
			exit;
	}
	fix_nated_register();
	fix_nated_contact();
	xlog("L_NOTICE","Register succeeded for $fU@$fd from $si cause $var(auth_code)");
	
	if (!save("location")) 
	{
		sl_reply_error();
	}

	$var(body) = "domain=" + $fd + "&ip=" + $si" + "&user=" + $fU + "&contact=" + $hdr(Contact) + "&expires=" + $hdr(Expires) + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_post("{{{api_url}}}/user/storeRegistration", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), REGISTER_STORE);

	exit;
}

route[REGISTER_STORE] {
	xlog("in register store resume.. rc = $rc\r\n");
	$var(rc) = $rc;

	if ($var(rc) < 0) 
	{
		#send_reply(500, "Server Internal Error");
		exit;
	}

	if ($var(rcode) != 204) 
	{
		#send_reply(403, "Forbidden (scenario 3)");
		exit;
	}

	exit;
}

route[HOSTED_TRUNK_REGISTER] {
	xlog("REG in hosted trunk register resume.. rc = $rc\r\n");
	$var(rc) = $rc;

	if ($var(rc) < 0) 
	{
		send_reply(500, "Server Internal Error");
		exit;
	}

	if ($var(rcode) != 204) 
	{
		send_reply(403, "Forbidden (scenario 4)");
		exit;
	}

	xlog("REG checking auth rc = $rc\r\n");
	$var(auth_code) = www_authorize("", "subscriber");
	if ($var(auth_code) == -1 || $var(auth_code) == -2) 
	{
		## uncomment to enable fail2ban
		#xlog("L_NOTICE","REG Auth error for $fU@$fd from $si cause $var(auth_code)");
		#exit;
	}

	if ( $var(auth_code) < 0 ) 
	{
			www_challenge("", "auth,auth-int");
			exit;
	}
	fix_nated_register();
	fix_nated_contact();
	xlog("L_NOTICE","Register succeeded for $fU@$fd from $si cause $var(auth_code)");
	
	if (!save("location")) 
	{
		sl_reply_error();
	}

	exit;
}

route[SIP_REPORT] {
	xlog("in sip report resume.. rc = $rc\r\n");
	exit;
}

route[INCOMING_MS_VALIDATE_1_ROUTE] {
	if ($var(rcode) != 204) 
	{
		send_reply(500, "Media server Routing Failed (scenario 1)");
		exit;
	}

	append_hf("X-LineBlocs-RingSubscriber: true\r\n");
	uac_replace_from("", "sip:$fU@$fd");
	$ru = "sip:" + $rU + "@" + $hdr(X-LineBlocs-Domain);
	route(RELAY);
	exit;
}

route[INCOMING_MS_VALIDATE_2_ROUTE] {
	if ($var(rcode) != 204) 
	{
		send_reply(500, "Media server Routing Failed (scenario 2)");
		exit;
	}

	$var(body) = "callid=" + $hdr(Call-ID) + "&apiid=" + $hdr(X-LineBlocs-API-CallId) + "&source=" + $si;
	$var(reg) = "/\+/%2B/g";
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_post("{{{api_url}}}/call/setSIPCallID", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), MS_PSTN_START_ROUTE);
	exit;
}

route[MS_PSTN_START_ROUTE] {
	if ($var(rcode) != 200) 
	{
		send_reply(500, "Media server Routing Failed (scenario 2)");
		exit;
	}

	$var(query) = "from=" + $fU + "&to=" + $tU + "&domain=" + $hdr(X-LineBlocs-Domain) + "&source=" + $si + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";

	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_get("{{{api_url}}}/user/getPSTNProviderIP?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), MS_PSTN_PROCESS_ROUTE);
	exit;
}


route[MS_PSTN_PROCESS_ROUTE] {
	if ($var(rcode) != 200) 
	{
		send_reply(500, "Media server Failed");
		exit;
	}

	# initiate routing data...
	$avp(body) = $(var(body));

	xlog("received JSON data: $(var(body))\r\n");
	$json(object) := $(avp(body));
	$ru = "sip:" + $(json(object/did)) + "@" + $(json(object/ip_addr));
	$avp(pstn_ru_addr) = $ru;
	$var(body) = "ip="  + $(json(object/ip_addr)) +  "&apiid=" + $hdr(X-LineBlocs-API-CallId);
	$var(reg) = "/\+/%2B/g";

	# tell API what provider is being used...

	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_post("{{{api_url}}}/call/setProviderByIP", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), MS_PSTN_AND_FINALIZE_ROUTING);
	exit;
}

route[MS_PSTN_AND_FINALIZE_ROUTING] {
	xlog("AVP data from route: $avp(pstn_ru_addr)\r\n");

	if ($var(rcode) != 200) 
	{
		send_reply(500, "Media server Routing Failed (scenario 3)");
		exit;
	}

	# start routing
	route(RELAY_MS_TO_PSTN);
	exit;
}

route[RELAY_MS_TO_PSTN] {

	$ru = $avp(pstn_ru_addr);
	xlog("L_INFO", "Relaying call to carrier at IP: $ru\n");
	# check if this request is a invite
	append_hf("X-LineBlocs-Parent-Call-ID: $hdr(Call-ID)\r\n");
	if (is_method("INVITE")) 
	{
		# for each branch we will call the function below
		
		t_on_branch("PER_BRANCH_OPS");

		# for each reply we will call the function below
		
		t_on_reply("PSTN_HANDLE_NAT");

		# if the call was not completed, so failure route
		t_on_failure("PSTN_FAILURE");


		if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
		{
			# user identified as behing a nat
			#xlog("we are on route relay, user behind nat");
			fix_nated_contact();
		}

		# if we have an application/sdp on our body, so we execute
        # the rtpproxy_offer
		if(has_body("application/sdp"))
		{
			#xlog("we have sdp on this $rm");
			#rtpproxy_offer("froc", "{{{public_ipv4}}}");
			route(RTPENGINE_OFFER);
		}
	
		if (lookup("location")) 
		{
			#xlog("request uri is now $ru");
		}
	}

	# removing the rtpproxy session
	if(is_method("CANCEL|BYE"))
	{
		#xlog("L_NOTICE", "route sending BYE to other end..  info from: $fu, to: $tu");
		#rtpproxy_unforce();
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
      		send_reply(500,"Internal Error");
	};

	#route(POST_CALL_PROC_ROUTE);
}

route[VERIFY_CALLER_ROUTE] {
	xlog("verify caller result $rc\r\n");
	if ($var(rcode) != 204) 
	{
		$var(body) = "domain=" + $fd + "&type=verify-callerid-failed" + "&addr=" + $si;
		$var(reg) = "/\+/%2B/g";

		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_post("{{{api_url}}}/debugger/createLogSimple", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), VERIFY_FORBIDDEN);
		send_reply(403, "Forbidden (scenario 5)");
		exit;
	}

	xlog("making call now..");
	$var(query) = "username=" + $fu + "&domain=" + $fd + "&routerip=" +  $avp(G_PUBLIC_IP) + "&addr=" + $si;
	$var(reg) = "/\+/%2B/g";

	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_get("{{{api_url}}}/user/getUserAssignedIP?username=$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), PSTN_QUERY_ROUTE);
}

route[VERIFY_FORBIDDEN] {
	send_reply(403, "Forbidden (scenario 6)");
	exit;
}

route[PSTN_QUERY_ROUTE] {
	xlog("pstn query result $(var(body))\r\n");

	xlog("req number before URL decode: $rU\r\n");
	$var(reg) = "/%2B|%E2|%80|%AC|%91//g";
	$var(reqnum) = $(rU{re.subst,$var(reg)});
	xlog("req number after URL decode: $(var(reqnum))\r\n");
	$ru = "sip:" + $var(reqnum) + "@" + $var(body);
	append_hf("X-LineBlocs-Key: {{{lineblocs_key}}}\r\n");
	append_hf("X-LineBlocs-Call-Type: pstn\r\n");
	append_hf("X-LineBlocs-Direction: outgoing-proxy\r\n");
	uac_replace_from("", "sip:$fU@$fd");

	# check if this request is a invite
	if (is_method("INVITE")) 
	{
		# for each branch we will call the function below
		t_on_branch("PER_BRANCH_OPS");

		# for each reply we will call the function below
		t_on_reply("HANDLE_NAT");

		# if the call was not completed, so failure route
		t_on_failure("PSTN_FAILURE");

		if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
		{
			# user identified as behing a nat
			#xlog("we are on route relay, user behind nat");
			fix_nated_contact();
		}

		# if we have an application/sdp on our body, so we execute
		# the rtpproxy_offer
		if(has_body("application/sdp"))
		{
			#xlog("we have sdp on this $rm");
# 			rtpproxy_offer("froc", "{{{public_ipv4}}}");
			route(RTPENGINE_OFFER);
		}
	
	}

	# removing the rtpproxy session
	if(is_method("CANCEL|BYE"))
	{
		#rtpproxy_unforce();
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
		send_reply(500,"Internal Error");
	};

	#route(POST_CALL_PROC_ROUTE);
}

route[MEDIASERVICE_QUERY_ROUTE] {
	$ru = "sip:" + $rU + "@" + $var(body);
	append_hf("X-LineBlocs-Key: {{{lineblocs_key}}}\r\n");
	append_hf("X-LineBlocs-Call-Type: media\r\n");
	append_hf("X-LineBlocs-Direction: outgoing-proxy\r\n");

	if (is_method("INVITE")) 
	{
		# for each branch we will call the function below
		t_on_branch("PER_BRANCH_OPS");

		# for each reply we will call the function below
		t_on_reply("HANDLE_NAT");

		# if the call was not completed, so failure route
		t_on_failure("MISSED_CALL");

		if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
		{
			# user identified as behing a nat
			fix_nated_contact();
		}

		# if we have an application/sdp on our body, so we execute
		# the rtpproxy_offer
		if(has_body("application/sdp"))
		{
			#rtpproxy_offer("froc", "{{{public_ipv4}}}");
			route(RTPENGINE_OFFER);
		}
	}

	# removing the rtpproxy session
	if(is_method("CANCEL|BYE"))
	{
		#rtpproxy_unforce();
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
		send_reply(500,"Internal Error");
	};

	#route(POST_CALL_PROC_ROUTE);
}

route[ENDPOINT_QUERY_ROUTE] {
	$ru = "sip:" + $rU + "@" + $var(body);
	append_hf("X-LineBlocs-Key: {{{lineblocs_key}}}\r\n");
	append_hf("X-LineBlocs-Call-Type: endpoint\r\n");
	append_hf("X-LineBlocs-Direction: outgoing-proxy\r\n");

	# check if this request is a invite
	if (is_method("INVITE")) 
	{
		# for each branch we will call the function below
		t_on_branch("PER_BRANCH_OPS");

		# for each reply we will call the function below
		t_on_reply("HANDLE_NAT");

		# if the call was not completed, so failure route
		t_on_failure("MISSED_CALL");

		if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
		{
			# user identified as behing a nat
			fix_nated_contact();
		}

		# if we have an application/sdp on our body, so we execute
		# the rtpproxy_offer
		if(has_body("application/sdp"))
		{
			#rtpproxy_offer("froc", "{{{public_ipv4}}}");
			route(RTPENGINE_OFFER);
		}
	}

	# removing the rtpproxy session
	if(is_method("CANCEL|BYE"))
	{
		#rtpproxy_unforce();
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
		send_reply(500,"Internal Error");
	};


	#route(POST_CALL_PROC_ROUTE);
}

branch_route[PER_BRANCH_OPS] {
	exit;
}

onreply_route[HANDLE_NAT] {
	# capture any sip packets
	sip_capture();	

	# we receive a reply, we need to check about application/sdp 
	# on our body, if we have, we answer that
	if(has_body("application/sdp"))
	{
		# rtpproxy_answer("froc", "{{{public_ipv4}}}");
		# offering rtpproxy on a non ack message
		# rtpproxy_offer("froc", "{{{public_ipv4}}}");	
		if (t_check_status("18[0-3]|2[0-9][0-9]")){
			route(RTPENGINE_ANSWER);
			#rtpengine_manage();
		}
	}

	# here we try to identify if the user is behind a nat again
	# but now is the second user (the called user) 
	if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
	{
		fix_nated_contact();
	}
}

onreply_route[PSTN_HANDLE_NAT] {
	# capture any sip packets
	sip_capture();

	# we receive a reply, we need to check about application/sdp 
	# on our body, if we have, we answer that

	# if(is_method("ACK") && has_body("application/sdp"))

	if ($ct =~ "invalid" || $ct =~ "transport=ws") {
	# if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
	#  {
                fix_nated_contact();
        }

	
	if (has_body("application/sdp") && nat_uac_test("private-sdp"))
	{
		fix_nated_sdp("rewrite-origin-ip");
	}

	if(is_method("ACK") && has_body("application/sdp")){
		# rtpproxy_answer("froc", "{{{public_ipv4}}}");
		route(RTPENGINE_ANSWER);
	} else if(has_body("application/sdp")) {
		# offering rtpproxy on a non ack message
		# rtpproxy_offer("froc", "{{{public_ipv4}}}");	
		route(RTPENGINE_OFFER);
	}
	# here we try to identify if the user is behind a nat again
	# but now is the second user (the called user) 
	# update SIP details
	$var(body) = "requestto=" + $ru + "&user=" + $fU + "&domain=" + $fd + "&callid=" + $hdr(Call-ID) + "&status=" + $rs;
	$var(reg) = "/\+/%2B/g";
	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_post("{{{api_url}}}/carrier/createSIPReport", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), SIP_REPORT);
}

failure_route[MISSED_CALL] {
	if (t_was_cancelled()) 
	{
		exit;
	}
}

route[RELAY_TO_USER_TRUNK] {
	xlog("pstn query result $(var(body))\r\n");
	$ru = "sip:" + $rU + "@" + $hdr(X-Lineblocs-User-SIP-Trunk-Addr);
	append_hf("X-LineBlocs-Call-Type: pstn\r\n");
	append_hf("X-LineBlocs-Direction: incoming-pstn-to-trunk\r\n");
	uac_replace_from("", "sip:$fU@$fd");

	# check if this request is a invite
	if (is_method("INVITE")) 
	{
		# for each branch we will call the function below
		t_on_branch("PER_BRANCH_OPS");

		# for each reply we will call the function below
		t_on_reply("HANDLE_NAT");

		# if the call was not completed, so failure route
		t_on_failure("PSTN_FAILURE");

		if(nat_uac_test("private-contact,private-sdp,private-via,diff-ip-src-via,diff-port-src-via,diff-ip-src-contact,diff-port-src-contact"))
		{
			# user identified as behing a nat
			#xlog("we are on route relay, user behind nat");
			fix_nated_contact();
		}

		# if we have an application/sdp on our body, so we execute
		# the rtpproxy_offer
		if(has_body("application/sdp"))
		{
			#xlog("we have sdp on this $rm");
# 			rtpproxy_offer("froc", "{{{public_ipv4}}}");
			route(RTPENGINE_OFFER);
		}
	}

	# removing the rtpproxy session
	if(is_method("CANCEL|BYE"))
	{
		rtpengine_delete();
	}

	if (!t_relay()) 
	{
 		send_reply(500,"Internal Error");
	};

	#route(POST_CALL_PROC_ROUTE);
}

failure_route[PSTN_FAILURE] {
	
	if (t_was_cancelled())
	{
		exit;
	}

	$var(body) = "requestto=" + $ru + "&user=" + $fU + "&domain=" + $fd + "&callid=" + $hdr(Call-ID) + "&status=" + $rs;
	$var(reg) = "/\+/%2B/g";

	rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
	async(rest_post("{{{api_url}}}/carrier/createSIPReport", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), SIP_REPORT);
}

route[CAPTURE_HEP_ROUTE] {

	#Logs Or Stats
	if($var(proto) == 100 || $var(proto) == 99) {
		if ($var(correlation_id) == null) {
			xlog("NO CORRELATION ID! SET SOMETHING OR DROP");
			exit;
		}
		/* get a generic chunk */
		hep_get("proto_type", "utf8-string", $var(data), $var(vid));
		$var(proto_type) = "3"; /* 0x03 - SDP protocol */

		report_capture($var(correlation_id), "rtcp_log");
		/* setting the 2nd parameter, even if setting it to null, is mandatory in order to be able to set proto type */
		report_capture($var(correlation_id), , $var(proto_type));
		report_capture($var(correlation_id), "rtcp_log", $var(proto_type));
		exit;
	}

	hep_resume_sip();
	
}

route[POST_CALL_PROC_ROUTE] {
	xlog("POST_CALL_PROC_ROUTE was triggered");
	rtpengine_use_set(1);	
	
	if(is_method("INVITE")) {
		xlog("POST_CALL_PROC_ROUTE handling INVITE event");
		$var(query) = "invite_ip=" + $ru;

		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_get("{{{api_url}}}/user/logCallInviteEvent?$(var(query){re.subst,$var(reg)})", $var(body), $var(ct), $var(rcode)), INVITE_REPORT_ROUTE);
	} else if (is_method("BYE")) {
		xlog("POST_CALL_PROC_ROUTE handling BYE event");

		xlog("L_INFO", "cleaning up SIP call\n");
		$var(body) = "callid=" + $hdr(Call-ID) + "&source=" + $si;
		$var(reg) = "/\+/%2B/g";
		rest_append_hf("X-Lineblocs-Api-Token: {{{lineblocs_key}}}");
		async(rest_post("{{{api_url}}}/user/processCDRsAndBill", "$(var(body){re.subst,$var(reg)})", "application/x-www-form-urlencoded", $var(body), $var(ctype), $var(rcode)), FINALIZE_SIP_CALL);
	}
	exit;
}

route[FINALIZE_SIP_CALL] {
	if ($var(rcode) != 204) 
	{
		xlog("L_INFO", "important: error occured while creating CDRs\n");
		send_reply(500, "ERROR while processing BYE event (scenario 1)");
		exit;
	}

	xlog("L_INFO", "created CDRs and billed user successfully.\n");
	exit;
}

route[INVITE_REPORT_ROUTE] {
	xlog("INVITE_REPORT_ROUTE callback triggered");
	exit;
}

route[BYE_REPORT_ROUTE] {
	xlog("BYE_REPORT_ROUTE callback triggered");
	exit;
}

route[RTPENGINE_OFFER] {
    $var(rtp_flags) = "";

    #
    # OFFER goes in the direction of the request being forwarded:
    # - If the *destination* is WebRTC -> we must produce SAVPF/DTLS/ICE toward it
    # - Else (destination is SIP) -> produce RTP/AVP toward it
    #

    if (isbflagset("DST_WS")) {
        # Anything -> WebRTC destination
        $var(rtp_flags) = "rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force UDP/TLS/RTP/SAVPF";
    } else {
        # Anything -> SIP destination
        # Keep SIP side clean: no mux, no DTLS, no ICE
        $var(rtp_flags) = "DTLS=off SDES-off ICE=remove RTP/AVP";
        # Only keep SIP-source-address if you truly need it
        $var(rtp_flags) = $var(rtp_flags) + " SIP-source-address";
    }

    # Always pin the public media address
    $var(rtp_flags) = $var(rtp_flags) + " media-address=" + $avp(G_PUBLIC_IP);

    # Common flags
    $var(rtp_flags) = "replace-origin replace-session-connection " + $var(rtp_flags);

    rtpengine_use_set(1);
    xlog("L_INFO", "RTP OFFER Flags: $var(rtp_flags)\n");
    rtpengine_offer("$var(rtp_flags)");
}


route[RTPENGINE_ANSWER] {
    $var(ans_flags) = "";

    #
    # ANSWER is generated for the direction back to the original caller:
    # - If the *source/original caller* is WebRTC -> answer must be WebRTC compatible
    # - Else -> answer must be SIP compatible
    #

    if (isflagset("SRC_WS")) {
        # Reply back to WebRTC caller
        # Force mux and ICE; DTLS passive is correct for most deployments
        $var(ans_flags) = "rtcp-mux-require generate-mid DTLS=passive SDES-off ICE=force UDP/TLS/RTP/SAVPF";
    } else {
        # Reply back to SIP caller
        $var(ans_flags) = "DTLS=off SDES-off ICE=remove RTP/AVP";
        $var(ans_flags) = $var(ans_flags) + " SIP-source-address";
    }

    # Always pin the public media address
    $var(ans_flags) = $var(ans_flags) + " media-address=" + $avp(G_PUBLIC_IP);

    # Common flags
    $var(ans_flags) = "replace-origin replace-session-connection " + $var(ans_flags);

    rtpengine_use_set(1);
    xlog("L_INFO", "RTP Answer Flags: $var(ans_flags)\n");
    rtpengine_answer("$var(ans_flags)");
}